"""
/***************************************************************************
 FireToolbox
                                 A QGIS plugin
 A collection of fire insights related algorithms
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2023-08-30
        copyright            : (C) 2024 by Diego Teran - Fire2a.com
        email                : FIX-ME
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

from fire2a.raster import get_rlayer_data, get_rlayer_info
from qgis.core import (QgsProcessing, QgsProcessingAlgorithm, QgsProcessingParameterMultipleLayers,
                       QgsProcessingParameterRasterDestination, QgsProcessingParameterFile, QgsProject)
from qgis.PyQt.QtCore import QCoreApplication

import torch
from .firescarmapping.model_u_net import model, device
from .firescarmapping.as_dataset import create_datasetAS
import numpy as np
from torch.utils.data import DataLoader


class FireScarMapper(QgsProcessingAlgorithm):
    IN_BEFORE = "BeforeRasters"
    IN_AFTER = "AfterRasters"
    OUT_SCARS = "OutputScars"
    IN_MODEL = "Trained Model"

    def initAlgorithm(self, config):
        self.addParameter(
            QgsProcessingParameterMultipleLayers(
                name=self.IN_BEFORE,
                description=self.tr("Input rasters of non burned landscape"),
                layerType=QgsProcessing.TypeRaster,
                defaultValue=[],
                optional=False,
            )
        )
        self.addParameter(
            QgsProcessingParameterMultipleLayers(
                name=self.IN_AFTER,
                description=self.tr("Input rasters of burnt landscape"),
                layerType=QgsProcessing.TypeRaster,
                defaultValue=[],
                optional=False,
            )
        )
        self.addParameter(
            QgsProcessingParameterFile(
                name=self.IN_MODEL,
                description=self.tr("Trained model file"),
                extension="model",
                optional=False,
            )
        )
        self.addParameter(
            QgsProcessingParameterRasterDestination(
                name=self.OUT_SCARS,
                description=self.tr("Output mapped scars in a single raster"),
            )
        )

    def processAlgorithm(self, parameters, context, feedback):
        before = self.parameterAsLayerList(parameters, self.IN_BEFORE, context)
        feedback.pushDebugInfo(f"Input rasters:\n names: {[ r.name() for r in before]}\ntypes: {[ r.rasterType() for r in before]}")
        burnt = self.parameterAsLayerList(parameters, self.IN_AFTER, context)
        feedback.pushDebugInfo(f"Input rasters:\n names: {[ r.name() for r in burnt]}\ntypes: {[ r.rasterType() for r in burnt]}")
        model_path = self.parameterAsFile(parameters, self.IN_MODEL, context)
        
        if len(before) != len(burnt):
            raise QgsProcessingException("The number of before and burnt rasters must be the same")
        rasters = []
        for i, layer in enumerate(before + burnt):
            adict = {
                "type": "before" if i < len(before) else "burnt",
                "id": i,
                "qid": layer.id(),
                "name": layer.name(),
                "data": get_rlayer_data(layer),
                "layer": layer,
            }
            adict.update(get_rlayer_info(layer))
            rasters += [adict]
        #feedback.pushDebugInfo(f"{rasters=}, {len(rasters)=} {[r['data'].shape for r in rasters]}")

        before_files = []
        after_files = []
        
        for i in range(len(rasters)//2):
            before_files.append(rasters[i]['data'])
            for j in range(len(rasters)//2):
                if rasters[i]['name'][7:] == rasters[j + (len(rasters)//2)]['name'][7:]:
                    after_files.append(rasters[j + (len(rasters)//2)]['data'])
            
        device = torch.device('cuda:0' if torch.cuda.is_available() else 'cpu')
        model.load_state_dict(torch.load(model_path, map_location=torch.device('cpu')))

        np.random.seed(3)
        torch.manual_seed(3)    
        
        data_eval = create_datasetAS(before_files, after_files, mult=1)
        
        batch_size = 1 # 1 to create diagnostic images, any value otherwise
        all_dl = DataLoader(data_eval, batch_size=batch_size)#, shuffle=True)

        model.eval()

        def print_matrix(matrix):
            """
            Imprime la matriz de manera legible, reemplazando 0 y 1 con caracteres distinguibles.
            
            Args:
                matrix (list): La matriz representada como una lista de listas.
            """
            # Mapea los valores de la matriz a caracteres distinguibles
            char_map = {0.0: ' _ ', 1.0: ' X '}  # Puedes cambiar los caracteres según tus preferencias
            
            # Itera sobre cada fila de la matriz
            for row in matrix:
                # Convierte los valores de la fila usando el mapeo de caracteres y únelos en una cadena
                row_str = ''.join(char_map[val] for val in row)
                # Imprime la fila
                feedback.pushDebugInfo(row_str)

        for i, batch in enumerate(all_dl):
            x = batch['img'].float().to(device)
            output = model(x).cpu()

            # obtain binary prediction map
            pred = np.zeros(output.shape)
            pred[output >= 0] = 1
            
            np.set_printoptions(threshold=np.inf, linewidth=np.inf)
            generated_matrix = pred[0][0]
            print_matrix(generated_matrix)
            #feedback.pushDebugInfo(str(generated_matrix.tolist()))
            feedback.pushDebugInfo(" ")
            feedback.pushDebugInfo(" ")

        return {}

    def name(self):
        return "firescarmapper"
    
    def displayName(self):
        return self.tr("Fire Scar Mapper")

    def tr(self, string):
        return QCoreApplication.translate("Processing", string)

    def createInstance(self):
        return FireScarMapper()
