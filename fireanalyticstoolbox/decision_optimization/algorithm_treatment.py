# -*- coding: utf-8 -*-
"""
/***************************************************************************
 ProcessingPluginClass
                                 A QGIS plugin
 Description of the p p
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2024-03-20
        copyright            : (C) 2024 by fdo
        email                : fbadilla@ing.uchile.cl
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
__author__ = "fdo"
__date__ = "2024-03-20"
__copyright__ = "(C) 2024 by fdo"
__version__ = "$Format:%H$"


from io import StringIO
from itertools import compress, product
from multiprocessing import cpu_count
from os import environ, pathsep
from pathlib import Path
from platform import system as platform_system
from shutil import which
from time import sleep

import numpy as np
import pandas as pd
import processing
from fire2a.raster import get_rlayer_data, get_rlayer_info
from processing.tools.system import getTempFilename
from pyomo import environ as pyo
from pyomo.common.errors import ApplicationError
from pyomo.opt import SolverFactory, SolverStatus, TerminationCondition
from qgis.core import (Qgis, QgsFeature, QgsFeatureRequest, QgsFeatureSink, QgsField, QgsFields, QgsMessageLog,
                       QgsProcessing, QgsProcessingAlgorithm, QgsProcessingException, QgsProcessingParameterBoolean,
                       QgsProcessingParameterDefinition, QgsProcessingParameterFeatureSink,
                       QgsProcessingParameterFeatureSource, QgsProcessingParameterField, QgsProcessingParameterFile,
                       QgsProcessingParameterMultipleLayers, QgsProcessingParameterNumber,
                       QgsProcessingParameterRasterDestination, QgsProcessingParameterRasterLayer,
                       QgsProcessingParameterString)
from qgis.PyQt.QtCore import QByteArray, QCoreApplication, QVariant
from qgis.PyQt.QtGui import QIcon

from ..algorithm_utils import (QgsProcessingParameterRasterDestinationGpkg, array2rasterInt16, get_output_raster_format,
                               get_raster_data, get_raster_info, get_raster_nodata, run_alg_styler_bin, write_log)
from ..config import METRICS, NAME, SIM_OUTPUTS, STATS, TAG, jolo
from .doop import add_cbc_to_path, pyomo_init_algorithm, pyomo_parse_results, pyomo_run_model


class RasterTreatmentAlgorithm(QgsProcessingAlgorithm):
    """Algorithm that selects the most valuable polygons restriced to a total weight using a MIP solver"""

    IN_TRT = "current_treatment"
    IN_VAL = "current_value"
    IN_TRGTS = "target_values"

    IN_TREATS = "TreatmentsMatrix"

    IN_AREA = "Area"
    IN_BUDGET = "Budget"

    OUT_LAYER = "OUT_LAYER"
    GEOMETRY_CHECK_SKIP_INVALID = "GEOMETRY_CHECK_SKIP_INVALID"

    solver_exception_msg = ""

    if platform_system() == "Windows":
        add_cbc_to_path(QgsMessageLog)

    def initAlgorithm(self, config):
        """The form reads a vector layer and two fields, one for the value and one for the weight; also configures the weight ratio and the solver"""
        for raster in [self.IN_TRT, self.IN_VAL, self.IN_TRGTS]:
            self.addParameter(
                QgsProcessingParameterRasterLayer(
                    name=raster,
                    description=self.tr(f"Raster layer for {raster}"),
                    defaultValue=[QgsProcessing.TypeRaster],
                    optional=True,
                )
            )
        # treatments
        self.addParameter(
            QgsProcessingParameterFile(
                name=self.IN_TREATS,
                description=self.tr("Treatments Matrix (csv)"),
                behavior=QgsProcessingParameterFile.File,
                extension="csv",
            )
        )
        # AREA double
        qppn = QgsProcessingParameterNumber(
            name=self.IN_AREA,
            description=self.tr("Total Area"),
            type=QgsProcessingParameterNumber.Double,
            defaultValue=2024.03,
            optional=False,
            minValue=0.01,
        )
        qppn.setMetadata({"widget_wrapper": {"decimals": 2}})
        self.addParameter(qppn)
        # BUDGET double
        qppn = QgsProcessingParameterNumber(
            name=self.IN_BUDGET,
            description=self.tr("Total Budget"),
            type=QgsProcessingParameterNumber.Double,
            defaultValue=1312.01,
            optional=False,
            minValue=0.01,
        )
        qppn.setMetadata({"widget_wrapper": {"decimals": 2}})
        self.addParameter(qppn)

        # raster output
        self.addParameter(QgsProcessingParameterRasterDestinationGpkg(self.OUT_LAYER, self.tr("Raster Treatment")))

        # advanced skip invalid geometry
        qppb = QgsProcessingParameterBoolean(
            name=self.GEOMETRY_CHECK_SKIP_INVALID,
            description=self.tr(
                "Set invalid geometry check to GeometrySkipInvalid (more options clicking the wrench on the input poly layer)"
            ),
            defaultValue=True,
            optional=True,
        )
        qppb.setFlags(qppb.flags() | QgsProcessingParameterDefinition.FlagAdvanced)
        self.addParameter(qppb)

        pyomo_init_algorithm(self, config)

    def processAlgorithm(self, parameters, context, feedback):
        retdic = {}
        # report solver unavailability
        feedback.pushWarning(f"Solver unavailability:\n{self.solver_exception_msg}\n")
        # invalid geometry skip
        if self.parameterAsBool(parameters, self.GEOMETRY_CHECK_SKIP_INVALID, context):
            context.setInvalidGeometryCheck(QgsFeatureRequest.GeometrySkipInvalid)
            feedback.pushWarning("setInvalidGeometryCheck set to GeometrySkipInvalid")
        # read rasters
        rasters_dic = {}
        for raster in [self.IN_TRT, self.IN_VAL, self.IN_TRGTS]:
            layer = self.parameterAsRasterLayer(parameters, raster, context)
            rasters_dic[raster] = {
                "layer": layer,
                "data": get_rlayer_data(layer),
                "info": get_rlayer_info(layer),
            }
        # feedback.pushDebugInfo(f"{rasters_dic=}")
        retdic.update(rasters_dic)
        # read conversion table
        df = pd.read_csv(self.parameterAsFile(parameters, self.IN_TREATS, context))
        if list(df.index) != list(df.columns):
            raise QgsProcessingException("Conversion table must be square with the same index and columns")
        retdic["treat_mat"] = df
        # feedback.pushDebugInfo(f"{df=}")
        feedback.pushDebugInfo(f"{retdic=}")
        return rasters_dic

    def nope(self):
        # get raster data
        value_layer = self.parameterAsRasterLayer(parameters, self.IN_VALUE, context)
        value_data = get_raster_data(value_layer)
        value_nodata = get_raster_nodata(value_layer, feedback)
        value_map_info = get_raster_info(value_layer)

        dfa = pd.DataFrame.from_dict(
            dict(
                zip(
                    attr_names,
                    [
                        fids,
                        current_treatment,
                        current_value,
                        current_valuem2,
                        [feat.geometry().area() for feat in features],
                    ],
                )
            )
        )
        # feedback.pushDebugInfo(dfa)
        retdic["dfa"] = dfa
        # feedback.pushDebugInfo(dft)
        retdic["dft"] = dft

        budget = self.parameterAsDouble(parameters, self.IN_BUDGET, context)
        area = self.parameterAsDouble(parameters, self.IN_AREA, context)

        treat_names = np.unique(dft["treatment"].to_list() + current_treatment).tolist()
        # feedback.pushDebugInfo(f"{treat_names=}")
        retdic["treat_names"] = treat_names

        treat_table = np.zeros((len(dfa), len(treat_names)), dtype=bool)
        for i, current in dfa.iterrows():
            targets = dft[dft["fid"] == current["fid"]]
            for j, target in targets.iterrows():
                treat_table[i, treat_names.index(target["treatment"])] = True
        # feedback.pushDebugInfo(f"{treat_table=}")
        retdic["treat_table"] = treat_table

        # feedback.pushDebugInfo(f"instance read: {retdic=}")
        model = do_poly_treatment(treat_names, treat_table, dfa, dft, area, budget)
        results = pyomo_run_model(self, parameters, context, feedback, model)
        retval, solver_dic = pyomo_parse_results(results, feedback)
        retdic.update(solver_dic)

        if retval >= 1:
            return retdic

        # feedback.pushDebugInfo(f"{treat_names=}")
        treats_dic = {(i, k): pyo.value(model.X[i, k], exception=False) for i, k in model.FeasibleSet}
        # feedback.pushDebugInfo(f"{treats_dic=}")
        treats_arr = np.array([[treats_dic.get((i, k)) for k in model.T] for i in model.N], dtype=float)
        treats_arr = np.where(np.isnan(treats_arr), -1, treats_arr)
        summary = [np.max(row) for row in treats_arr]
        # feedback.pushDebugInfo(f"{treats_dic=}")
        # feedback.pushDebugInfo(f"{list(zip(treats_arr,summary))=}")

        msg = "Solution histogram:\n"
        hist = np.histogram(summary, bins=[-1] + list(range(len(treat_names))))[0]
        for trt, count in zip(["undecided"] + treat_names, hist):
            msg += f"{trt}: {count}\n"
        feedback.pushInfo(msg)

        fields = QgsFields()
        fields.append(QgsField(name="fid", type=QVariant.Int))  # , len=10))
        fields.append(QgsField(name="current", type=QVariant.String))  # , len=10))
        fields.append(QgsField(name="treatment", type=QVariant.String))  # , len=10))
        fields.append(QgsField(name="changed", type=QVariant.Bool))  # , len=10))

        (sink, dest_id) = self.parameterAsSink(
            parameters,
            self.OUT_LAYER,
            context,
            fields,
            layer.wkbType(),
            layer.sourceCrs(),
        )
        feedback.pushDebugInfo(f"{sink=}, {dest_id=}")

        total = 100.0 / len(features)
        for current, feat in enumerate(features):
            # Stop the algorithm if cancel button has been clicked
            if feedback.isCanceled():
                break
            # Prepare feature
            new_feat = QgsFeature(fields)
            ifid = int(feat.id())
            curr = feat[current_treatment_fieldname]

            smry = summary[fids.index(ifid)]
            if smry == -1:
                trgt = "undecided"
                chg = True
            elif smry == 0:
                trgt = ""
                chg = False
            elif smry == 1:
                trgt = treat_names[np.argmax(treats_arr[fids.index(ifid)])]
                chg = True
            else:
                feedback.reportError(f"Unexpected summary value: {smry}, for feature {ifid}")

            new_feat.setId(ifid)
            new_feat.setAttributes([ifid, curr, trgt, chg])
            new_feat.setGeometry(feat.geometry())
            # feedback.pushDebugInfo(
            #     f"{current=}, {new_feat.id()=}, {[treats_dic.get((ifid, tn)) for tn in treat_names]}"
            # )
            # Add a feature in the sink
            sink.addFeature(new_feat, QgsFeatureSink.FastInsert)
            # Update the progress bar
            feedback.setProgress(int(current * total))

        # if showing
        if context.willLoadLayerOnCompletion(dest_id):
            layer_details = context.layerToLoadOnCompletionDetails(dest_id)
            layer_details.groupName = "DecisionOptimizationGroup"
            layer_details.name = "TreatmentPolygons"
            layer_details.layerSortKey = 1
            processing.run(
                "native:setlayerstyle",
                {
                    "INPUT": dest_id,
                    "STYLE": str(Path(Path(__file__).parent, "treatment_polygon.qml")),
                },
                context=context,
                feedback=feedback,
                is_child_algorithm=True,
            )

        write_log(feedback, name=self.name())
        return retdic

    def name(self):
        """processing.run('provider:name',{..."""
        return "rastertreatment"

    def displayName(self):
        """
        Returns the translated algorithm name, which should be used for any
        user-visible display of the algorithm name.
        """
        return self.tr("AAA Raster Treatment")

    def group(self):
        return self.tr(self.groupId())

    def groupId(self):
        return "zexperimental"

    def tr(self, string):
        return QCoreApplication.translate("Processing", string)

    def createInstance(self):
        return RasterTreatmentAlgorithm()

    def helpUrl(self):
        return "https://www.github.com/fdobad/qgis-processingplugin-template/issues"

    def shortDescription(self):
        return self.tr(
            """<b>Objetive:</b> Maximize the changed value of the treated polygons<br> 
            <b>Decisions:</b> Which treatment to apply to each polygon (or no change)<br>
            <b>Contraints:</b><br>
            (a) fixed+area costs less than budget<br>
            (b) treated area less than total area<br> 
            <b>Inputs:</b><br>
            (i) A polygon layer with <b>current</b> attributes: [fid],<b>treatment, value, value/m2</b><br>
            (ii) A .csv table defining <b>target</b> treatments: <b>fid, treatment, value, value/m2, cost, cost/m2</b> (use these column names)<br>
            - fid is the feature id of each polygon so it's given in the attribute table, but must be specified in the .csv table<br>
            - current & target treatment are just strings, but each polygon needs at least one feasible treatment (one row)<br>
            - current & target values[/m2] weight towards the objective when no change (keep current) or a target treatment is recommended<br>
            (iii) <b>Budget</b> (same units than costs)<br>
            (iv) <b>Area</b> (same units than the geometry of the polygons)<br>
            <br>
            sample: """
            + (Path(__file__).parent / "treatments_sample").as_uri()
        )

    def icon(self):
        return QIcon(":/plugins/fireanalyticstoolbox/assets/firebreakmap.svg")


class PolyTreatmentAlgorithm(QgsProcessingAlgorithm):
    """Algorithm that selects the most valuable polygons restriced to a total weight using a MIP solver"""

    IN_LAYER = "IN_LAYER"
    IN_TRT = "treatment"
    IN_VAL = "value"
    IN_VALm2 = "value/m2"

    IN_TREATS = "TreatmentsTable"

    IN_AREA = "Area"
    IN_BUDGET = "Budget"

    OUT_LAYER = "OUT_LAYER"
    GEOMETRY_CHECK_SKIP_INVALID = "GEOMETRY_CHECK_SKIP_INVALID"

    solver_exception_msg = ""

    if platform_system() == "Windows":
        add_cbc_to_path(QgsMessageLog)

    def initAlgorithm(self, config):
        """The form reads a vector layer and two fields, one for the value and one for the weight; also configures the weight ratio and the solver"""
        # input layer
        self.addParameter(
            QgsProcessingParameterFeatureSource(
                name=self.IN_LAYER,
                description=self.tr("Input Polygons Layer"),
                types=[QgsProcessing.TypeVectorPolygon],
            )
        )
        # current treatment field
        self.addParameter(
            QgsProcessingParameterField(
                name=self.IN_TRT,
                description=self.tr(f"Attribute table field name for {self.IN_TRT}"),
                defaultValue=self.IN_TRT,
                parentLayerParameterName=self.IN_LAYER,
                type=Qgis.ProcessingFieldParameterDataType.String,
                allowMultiple=False,
                optional=False,
                defaultToAllFields=False,
            )
        )
        # value & value/m2 field
        for field_value in [self.IN_VAL, self.IN_VALm2]:
            self.addParameter(
                QgsProcessingParameterField(
                    name=field_value,
                    description=self.tr(f"Attribute table field name for {field_value} [0s if not provided]"),
                    defaultValue=field_value,
                    parentLayerParameterName=self.IN_LAYER,
                    type=Qgis.ProcessingFieldParameterDataType.Numeric,
                    allowMultiple=False,
                    optional=True,
                    defaultToAllFields=False,
                )
            )
        # treatments
        self.addParameter(
            QgsProcessingParameterFile(
                name=self.IN_TREATS,
                description=self.tr("Treatments table (fid,treatment,value,value/m2,cost,cost/m2)"),
                behavior=QgsProcessingParameterFile.File,
                extension="csv",
            )
        )
        # AREA double
        qppn = QgsProcessingParameterNumber(
            name=self.IN_AREA,
            description=self.tr("Total Area"),
            type=QgsProcessingParameterNumber.Double,
            defaultValue=2024.03,
            optional=False,
            minValue=0.01,
        )
        qppn.setMetadata({"widget_wrapper": {"decimals": 2}})
        self.addParameter(qppn)
        # BUDGET double
        qppn = QgsProcessingParameterNumber(
            name=self.IN_BUDGET,
            description=self.tr("Total Budget"),
            type=QgsProcessingParameterNumber.Double,
            defaultValue=1312.01,
            optional=False,
            minValue=0.01,
        )
        qppn.setMetadata({"widget_wrapper": {"decimals": 2}})
        self.addParameter(qppn)

        # output layer
        self.addParameter(QgsProcessingParameterFeatureSink(self.OUT_LAYER, self.tr("Polygon Treatment")))

        # advanced skip invalid geometry
        qppb = QgsProcessingParameterBoolean(
            name=self.GEOMETRY_CHECK_SKIP_INVALID,
            description=self.tr(
                "Set invalid geometry check to GeometrySkipInvalid (more options clicking the wrench on the input poly layer)"
            ),
            defaultValue=True,
            optional=True,
        )
        qppb.setFlags(qppb.flags() | QgsProcessingParameterDefinition.FlagAdvanced)
        self.addParameter(qppb)

        pyomo_init_algorithm(self, config)

    def processAlgorithm(self, parameters, context, feedback):
        retdic = {}
        # report solver unavailability
        feedback.pushWarning(f"Solver unavailability:\n{self.solver_exception_msg}\n")
        # invalid geometry skip
        if self.parameterAsBool(parameters, self.GEOMETRY_CHECK_SKIP_INVALID, context):
            context.setInvalidGeometryCheck(QgsFeatureRequest.GeometrySkipInvalid)
            feedback.pushWarning("setInvalidGeometryCheck set to GeometrySkipInvalid")
        # poly layer
        layer = self.parameterAsSource(parameters, self.IN_LAYER, context)
        feedback.pushDebugInfo(
            f"{layer.sourceName()=}, {layer.fields().names()=}, {layer.wkbType()=}, {layer.sourceCrs().authid()=}, {layer.featureCount()=}"
        )
        retdic["layer"] = layer
        # fields
        request_fields = []
        # required
        current_treatment_fieldname = self.parameterAsString(parameters, self.IN_TRT, context)
        request_fields += [current_treatment_fieldname]
        # optional
        if current_value_fieldname := self.parameterAsString(parameters, self.IN_VAL, context):
            request_fields += [current_value_fieldname]
        if current_valuem2_fieldname := self.parameterAsString(parameters, self.IN_VALm2, context):
            request_fields += [current_valuem2_fieldname]
        qfr = QgsFeatureRequest().setSubsetOfAttributes(request_fields, layer.fields())
        features = list(layer.getFeatures(qfr))
        feedback.pushWarning(
            f"Valid polygons: {len(features)}/{layer.featureCount()} {len(features)/layer.featureCount():.2%}\n"
        )
        # required
        current_treatment = [feat.attribute(current_treatment_fieldname) for feat in features]
        fids = [feat.id() for feat in features]
        # get else not provided
        if current_value_fieldname:
            current_value = [feat.attribute(current_value_fieldname) for feat in features]
        else:
            current_value = [0] * len(features)
        if current_valuem2_fieldname:
            current_valuem2 = [feat.attribute(current_valuem2_fieldname) for feat in features]
        else:
            current_valuem2 = [0] * len(features)
        attr_names = ["fid", "treatment", "value", "value/m2", "area"]
        dfa = pd.DataFrame.from_dict(
            dict(
                zip(
                    attr_names,
                    [
                        fids,
                        current_treatment,
                        current_value,
                        current_valuem2,
                        [feat.geometry().area() for feat in features],
                    ],
                )
            )
        )
        # feedback.pushDebugInfo(dfa)
        retdic["dfa"] = dfa
        # read tables
        dft = pd.read_csv(self.parameterAsFile(parameters, self.IN_TREATS, context))
        for col in ["fid", "treatment", "value", "value/m2", "cost", "cost/m2"]:
            if col not in dft.columns:
                raise QgsProcessingException(f"Column {col} not found in {dft.columns}")
        # feedback.pushDebugInfo(dft)
        retdic["dft"] = dft

        budget = self.parameterAsDouble(parameters, self.IN_BUDGET, context)
        area = self.parameterAsDouble(parameters, self.IN_AREA, context)

        treat_names = np.unique(dft["treatment"].to_list() + current_treatment).tolist()
        # feedback.pushDebugInfo(f"{treat_names=}")
        retdic["treat_names"] = treat_names

        treat_table = np.zeros((len(dfa), len(treat_names)), dtype=bool)
        for i, current in dfa.iterrows():
            targets = dft[dft["fid"] == current["fid"]]
            for j, target in targets.iterrows():
                treat_table[i, treat_names.index(target["treatment"])] = True
        # feedback.pushDebugInfo(f"{treat_table=}")
        retdic["treat_table"] = treat_table

        # feedback.pushDebugInfo(f"instance read: {retdic=}")
        model = do_poly_treatment(treat_names, treat_table, dfa, dft, area, budget)
        results = pyomo_run_model(self, parameters, context, feedback, model)
        retval, solver_dic = pyomo_parse_results(results, feedback)
        retdic.update(solver_dic)

        if retval >= 1:
            return retdic

        # feedback.pushDebugInfo(f"{treat_names=}")
        treats_dic = {(i, k): pyo.value(model.X[i, k], exception=False) for i, k in model.FeasibleSet}
        # feedback.pushDebugInfo(f"{treats_dic=}")
        treats_arr = np.array([[treats_dic.get((i, k)) for k in model.T] for i in model.N], dtype=float)
        treats_arr = np.where(np.isnan(treats_arr), -1, treats_arr)
        summary = [np.max(row) for row in treats_arr]
        # feedback.pushDebugInfo(f"{treats_dic=}")
        # feedback.pushDebugInfo(f"{list(zip(treats_arr,summary))=}")

        msg = "Solution histogram:\n"
        hist = np.histogram(summary, bins=[-1] + list(range(len(treat_names))))[0]
        for trt, count in zip(["undecided"] + treat_names, hist):
            msg += f"{trt}: {count}\n"
        feedback.pushInfo(msg)

        fields = QgsFields()
        fields.append(QgsField(name="fid", type=QVariant.Int))  # , len=10))
        fields.append(QgsField(name="current", type=QVariant.String))  # , len=10))
        fields.append(QgsField(name="treatment", type=QVariant.String))  # , len=10))
        fields.append(QgsField(name="changed", type=QVariant.Bool))  # , len=10))

        (sink, dest_id) = self.parameterAsSink(
            parameters,
            self.OUT_LAYER,
            context,
            fields,
            layer.wkbType(),
            layer.sourceCrs(),
        )
        feedback.pushDebugInfo(f"{sink=}, {dest_id=}")

        total = 100.0 / len(features)
        for current, feat in enumerate(features):
            # Stop the algorithm if cancel button has been clicked
            if feedback.isCanceled():
                break
            # Prepare feature
            new_feat = QgsFeature(fields)
            ifid = int(feat.id())
            curr = feat[current_treatment_fieldname]

            smry = summary[fids.index(ifid)]
            if smry == -1:
                trgt = "undecided"
                chg = True
            elif smry == 0:
                trgt = ""
                chg = False
            elif smry == 1:
                trgt = treat_names[np.argmax(treats_arr[fids.index(ifid)])]
                chg = True
            else:
                feedback.reportError(f"Unexpected summary value: {smry}, for feature {ifid}")

            new_feat.setId(ifid)
            new_feat.setAttributes([ifid, curr, trgt, chg])
            new_feat.setGeometry(feat.geometry())
            # feedback.pushDebugInfo(
            #     f"{current=}, {new_feat.id()=}, {[treats_dic.get((ifid, tn)) for tn in treat_names]}"
            # )
            # Add a feature in the sink
            sink.addFeature(new_feat, QgsFeatureSink.FastInsert)
            # Update the progress bar
            feedback.setProgress(int(current * total))

        # if showing
        if context.willLoadLayerOnCompletion(dest_id):
            layer_details = context.layerToLoadOnCompletionDetails(dest_id)
            layer_details.groupName = "DecisionOptimizationGroup"
            layer_details.name = "TreatmentPolygons"
            layer_details.layerSortKey = 1
            processing.run(
                "native:setlayerstyle",
                {
                    "INPUT": dest_id,
                    "STYLE": str(Path(Path(__file__).parent, "treatment_polygon.qml")),
                },
                context=context,
                feedback=feedback,
                is_child_algorithm=True,
            )

        write_log(feedback, name=self.name())
        return retdic

    def name(self):
        """processing.run('provider:name',{..."""
        return "polytreatment"

    def displayName(self):
        """
        Returns the translated algorithm name, which should be used for any
        user-visible display of the algorithm name.
        """
        return self.tr("Polygon Treatment")

    def group(self):
        return self.tr("Decision Optimization")

    def groupId(self):
        return "do"

    def tr(self, string):
        return QCoreApplication.translate("Processing", string)

    def createInstance(self):
        return PolyTreatmentAlgorithm()

    def helpUrl(self):
        return "https://www.github.com/fdobad/qgis-processingplugin-template/issues"

    def shortDescription(self):
        return self.tr(
            """<b>Objetive:</b> Maximize the changed value of the treated polygons<br> 
            <b>Decisions:</b> Which treatment to apply to each polygon (or no change)<br>
            <b>Contraints:</b><br>
            (a) fixed+area costs less than budget<br>
            (b) treated area less than total area<br> 
            <b>Inputs:</b><br>
            (i) A polygon layer with <b>current</b> attributes: [fid],<b>treatment, value, value/m2</b><br>
            (ii) A .csv table defining <b>target</b> treatments: <b>fid, treatment, value, value/m2, cost, cost/m2</b> (use these column names)<br>
            - fid is the feature id of each polygon so it's given in the attribute table, but must be specified in the .csv table<br>
            - current & target treatment are just strings, but each polygon needs at least one feasible treatment (one row)<br>
            - current & target values[/m2] weight towards the objective when no change (keep current) or a target treatment is recommended<br>
            (iii) <b>Budget</b> (same units than costs)<br>
            (iv) <b>Area</b> (same units than the geometry of the polygons)<br>
            <br>
            sample: """
            + (Path(__file__).parent / "treatments_sample").as_uri()
        )

    def icon(self):
        return QIcon(":/plugins/fireanalyticstoolbox/assets/firebreakmap.svg")


def do_raster_treatment(treat_names, treat_matrix, current_values, target_values, px_area, area, budget):
    # Integer Programming
    m = pyo.ConcreteModel(name="polygon_treatment")

    # Sets
    m.N = pyo.Set(initialize=dfa.fid, ordered=True)
    m.T = pyo.Set(initialize=treat_names)
    m.FeasibleSet = pyo.Set(
        initialize=[
            (i, k) for i, k in product(m.N, m.T) if treat_table[dfa[dfa.fid == i].index[0], treat_names.index(k)]
        ]
    )
    # TODO
    # dfa[dfa.fid == i].index[0] -> dfa.set_index("fid").loc[i]
    dfa.set_index("fid", inplace=True)

    # Params
    m.area = pyo.Param(m.N, within=pyo.Reals, initialize=dfa["area"].to_dict())
    m.current_value = pyo.Param(m.N, within=pyo.Reals, initialize=dfa["value"].to_dict())
    m.current_valuem2 = pyo.Param(m.N, within=pyo.Reals, initialize=dfa["value/m2"].to_dict())
    m.target_value = pyo.Param(
        m.N, m.T, within=pyo.Reals, initialize=dft.set_index(["fid", "treatment"])["value"].to_dict()
    )
    m.target_valuem2 = pyo.Param(
        m.N, m.T, within=pyo.Reals, initialize=dft.set_index(["fid", "treatment"])["value/m2"].to_dict()
    )
    m.cost = pyo.Param(m.N, m.T, within=pyo.Reals, initialize=dft.set_index(["fid", "treatment"])["cost"].to_dict())
    m.costm2 = pyo.Param(
        m.N, m.T, within=pyo.Reals, initialize=dft.set_index(["fid", "treatment"])["cost/m2"].to_dict()
    )

    # initialize=df_stands[treatments].stack().to_dict(),

    # Variables
    m.X = pyo.Var(
        m.FeasibleSet,
        within=pyo.Binary,
    )
    # Constraints
    m.at_most_one_treatment = pyo.Constraint(
        m.N, rule=lambda m, ii: sum(m.X[i, k] for i, k in m.FeasibleSet if i == ii) <= 1
    )

    m.area_capacity = pyo.Constraint(rule=lambda m: sum(m.X[i, k] * m.area[i] for i, k in m.FeasibleSet) <= area)

    m.budget_capacity = pyo.Constraint(
        rule=lambda m: sum(m.X[i, k] * (m.cost[i, k] + m.costm2[i, k] * m.area[i]) for i, k in m.FeasibleSet) <= budget
    )

    # Objective
    m.obj = pyo.Objective(
        expr=sum(
            m.X[i, k] * (m.target_value[i, k] + m.target_valuem2[i, k] * m.area[i])
            + (1 - m.X[i, k]) * (m.current_value[i] + m.current_valuem2[i] * m.area[i])
            for i, k in m.FeasibleSet
        ),
        sense=pyo.maximize,
    )

    return m


def do_poly_treatment(treat_names, treat_table, dfa, dft, area, budget):
    # Integer Programming
    m = pyo.ConcreteModel(name="polygon_treatment")

    # Sets
    m.N = pyo.Set(initialize=dfa.fid, ordered=True)
    m.T = pyo.Set(initialize=treat_names)
    m.FeasibleSet = pyo.Set(
        initialize=[
            (i, k) for i, k in product(m.N, m.T) if treat_table[dfa[dfa.fid == i].index[0], treat_names.index(k)]
        ]
    )
    # TODO
    # dfa[dfa.fid == i].index[0] -> dfa.set_index("fid").loc[i]
    dfa.set_index("fid", inplace=True)

    # Params
    m.area = pyo.Param(m.N, within=pyo.Reals, initialize=dfa["area"].to_dict())
    m.current_value = pyo.Param(m.N, within=pyo.Reals, initialize=dfa["value"].to_dict())
    m.current_valuem2 = pyo.Param(m.N, within=pyo.Reals, initialize=dfa["value/m2"].to_dict())
    m.target_value = pyo.Param(
        m.N, m.T, within=pyo.Reals, initialize=dft.set_index(["fid", "treatment"])["value"].to_dict()
    )
    m.target_valuem2 = pyo.Param(
        m.N, m.T, within=pyo.Reals, initialize=dft.set_index(["fid", "treatment"])["value/m2"].to_dict()
    )
    m.cost = pyo.Param(m.N, m.T, within=pyo.Reals, initialize=dft.set_index(["fid", "treatment"])["cost"].to_dict())
    m.costm2 = pyo.Param(
        m.N, m.T, within=pyo.Reals, initialize=dft.set_index(["fid", "treatment"])["cost/m2"].to_dict()
    )

    # initialize=df_stands[treatments].stack().to_dict(),

    # Variables
    m.X = pyo.Var(
        m.FeasibleSet,
        within=pyo.Binary,
    )
    # Constraints
    m.at_most_one_treatment = pyo.Constraint(
        m.N, rule=lambda m, ii: sum(m.X[i, k] for i, k in m.FeasibleSet if i == ii) <= 1
    )

    m.area_capacity = pyo.Constraint(rule=lambda m: sum(m.X[i, k] * m.area[i] for i, k in m.FeasibleSet) <= area)

    m.budget_capacity = pyo.Constraint(
        rule=lambda m: sum(m.X[i, k] * (m.cost[i, k] + m.costm2[i, k] * m.area[i]) for i, k in m.FeasibleSet) <= budget
    )

    # Objective
    m.obj = pyo.Objective(
        expr=sum(
            m.X[i, k] * (m.target_value[i, k] + m.target_valuem2[i, k] * m.area[i])
            + (1 - m.X[i, k]) * (m.current_value[i] + m.current_valuem2[i] * m.area[i])
            for i, k in m.FeasibleSet
        ),
        sense=pyo.maximize,
    )

    return m


def do_poly_treatment_cube(treat_names, dfa, dft, area, budget):
    treat_cube = np.zeros((len(dfa), len(treat_names), len(treat_names)), dtype=bool)
    for i, current in dfa.iterrows():
        # get targets
        targets = dft[dft["fid"] == current["fid"]]
        for _, target in targets.iterrows():
            treat_cube[i, treat_names.index(current["treatment"]), treat_names.index(target["treatment"])] = True
    retdic["treat_cube"] = treat_cube
    # Integer Programming
    m = pyo.ConcreteModel(name="polygon_treatment_cube")

    # Sets
    m.N = pyo.Set(initialize=dfa.fid)
    m.T = pyo.Set(initialize=treat_names)
    m.FeasibleSet = pyo.Set(
        initialize=[
            (i, j, k)
            for i, j, k in product(m.N, m.T, m.T)
            if treat_cube[dfa[dfa.fid == i].index[0], treat_names.index(j), treat_names.index(k)]
        ]
    )
    # TODO
    # dfa[dfa.fid == i].index[0] -> dfa.set_index("fid").loc[i]

    # Params
    m.area = pyo.Param(m.N, within=pyo.Reals, initialize=dfa.set_index("fid")["area"].to_dict())
    m.current_value = pyo.Param(m.N, within=pyo.Reals, initialize=dfa.set_index("fid")["value"].to_dict())
    m.current_valuem2 = pyo.Param(m.N, within=pyo.Reals, initialize=dfa.set_index("fid")["value/m2"].to_dict())
    m.target_value = pyo.Param(
        m.N, m.T, within=pyo.Reals, initialize=dft.set_index(["fid", "treatment"])["value"].to_dict()
    )
    m.target_valuem2 = pyo.Param(
        m.N, m.T, within=pyo.Reals, initialize=dft.set_index(["fid", "treatment"])["value/m2"].to_dict()
    )
    m.cost = pyo.Param(m.N, m.T, within=pyo.Reals, initialize=dft.set_index(["fid", "treatment"])["cost"].to_dict())
    m.costm2 = pyo.Param(
        m.N, m.T, within=pyo.Reals, initialize=dft.set_index(["fid", "treatment"])["cost/m2"].to_dict()
    )

    # initialize=df_stands[treatments].stack().to_dict(),

    # Variables
    m.X = pyo.Var(
        m.FeasibleSet,
        within=pyo.Binary,
    )
    # Constraints
    m.at_most_one_treatment = pyo.Constraint(
        m.N, rule=lambda m, ii: sum(m.X[i, j, k] for i, j, k in m.FeasibleSet if i == ii) <= 1
    )

    m.area_capacity = pyo.Constraint(rule=lambda m: sum(m.X[i, j, k] * m.area[i] for i, j, k in m.FeasibleSet) <= area)

    m.budget_capacity = pyo.Constraint(
        rule=lambda m: sum(m.X[i, j, k] * (m.cost[i, k] + m.costm2[i, k] * m.area[i]) for i, j, k in m.FeasibleSet)
        <= budget
    )

    # Objective
    m.obj = pyo.Objective(
        expr=sum(
            m.X[i, j, k] * (m.target_value[i, k] + m.target_valuem2[i, k] * m.area[i])
            + (1 - m.X[i, j, k]) * (m.current_value[i] + m.current_valuem2[i] * m.area[i])
            for i, j, k in m.FeasibleSet
        ),
        sense=pyo.maximize,
    )
    # treats_dic = {(i, j, k): pyo.value(model.X[i, j, k], exception=False) for i, j, k in model.FeasibleSet}
    # treats_arr = np.array([treats_dic[i, j, k] for i, j, k in model.FeasibleSet])
    # treats_arr[treats_arr is None] = -1
    # for trt in treat_names:
    #     treats_arr[treats_arr == trt] = treat_names.index(trt)
    # msg = "Solution histogram:\n"
    # hist = np.histogram(treats_arr, bins=[-1] + list(range(len(treat_names))))[0]
    # for trt, count in zip(["undecided"] + treat_names, hist):
    #     msg += f"{trt}: {count}\n"
    # feedback.pushInfo(msg)

    return m
