# -*- coding: utf-8 -*-
"""
/***************************************************************************
 ProcessingPluginClass
                                 A QGIS plugin
 Description of the p p
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2024-03-20
        copyright            : (C) 2024 by fdo
        email                : fbadilla@ing.uchile.cl
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
__author__ = "fdo"
__date__ = "2024-03-20"
__copyright__ = "(C) 2024 by fdo"
__version__ = "$Format:%H$"


from contextlib import redirect_stderr, redirect_stdout
from io import StringIO
from itertools import compress, product
from multiprocessing import cpu_count
from os import environ, pathsep
from pathlib import Path
from platform import system as platform_system
from shutil import which
from time import sleep

import numpy as np
import pandas as pd
import processing
from processing.tools.system import getTempFilename
from pyomo import environ as pyo
from pyomo.common.errors import ApplicationError
from pyomo.opt import SolverFactory, SolverStatus, TerminationCondition
from qgis.core import (Qgis, QgsFeature, QgsFeatureRequest, QgsFeatureSink, QgsField, QgsFields, QgsMessageLog,
                       QgsProcessing, QgsProcessingAlgorithm, QgsProcessingException, QgsProcessingParameterBoolean,
                       QgsProcessingParameterDefinition, QgsProcessingParameterFeatureSink,
                       QgsProcessingParameterFeatureSource, QgsProcessingParameterField, QgsProcessingParameterFile,
                       QgsProcessingParameterMultipleLayers, QgsProcessingParameterNumber,
                       QgsProcessingParameterRasterDestination, QgsProcessingParameterRasterLayer,
                       QgsProcessingParameterString)
from qgis.PyQt.QtCore import QByteArray, QCoreApplication, QVariant
from qgis.PyQt.QtGui import QIcon
from scipy import stats

from ..algorithm_utils import (array2rasterInt16, get_output_raster_format, get_raster_data, get_raster_info,
                               get_raster_nodata, run_alg_styler_bin, write_log)
from ..config import METRICS, NAME, SIM_OUTPUTS, STATS, TAG, jolo
from .doop import SOLVER, FileLikeFeedback, add_cbc_to_path, check_solver_availability


class PolyTreatmentAlgorithm(QgsProcessingAlgorithm):
    """Algorithm that selects the most valuable polygons restriced to a total weight using a MIP solver"""

    IN_LAYER = "IN_LAYER"
    IN_TRT = "CurrentTreatment"
    IN_VAL = "CurrentValue"
    IN_VALm2 = "CurrentValue/m2"

    IN_TREATS = "TreatmentsCostsTable"

    IN_AREA = "Area"
    IN_BUDGET = "Budget"

    IN_EXECUTABLE = "EXECUTABLE"
    OUT_LAYER = "OUT_LAYER"
    GEOMETRY_CHECK_SKIP_INVALID = "GEOMETRY_CHECK_SKIP_INVALID"

    solver_exception_msg = ""

    if platform_system() == "Windows":
        add_cbc_to_path()

    def initAlgorithm(self, config):
        """The form reads a vector layer and two fields, one for the value and one for the weight; also configures the weight ratio and the solver"""
        # input layer
        self.addParameter(
            QgsProcessingParameterFeatureSource(
                name=self.IN_LAYER,
                description=self.tr("Input Polygons Layer"),
                types=[QgsProcessing.TypeVectorPolygon],
            )
        )
        # current treatment field
        self.addParameter(
            QgsProcessingParameterField(
                name=self.IN_TRT,
                description=self.tr(f"Attribute table field name for {self.IN_TRT}"),
                defaultValue=self.IN_TRT,
                parentLayerParameterName=self.IN_LAYER,
                type=Qgis.ProcessingFieldParameterDataType.String,
                allowMultiple=False,
                optional=False,
                defaultToAllFields=False,
            )
        )
        # value & value/m2 field
        for field_value in [self.IN_VAL, self.IN_VALm2]:
            self.addParameter(
                QgsProcessingParameterField(
                    name=field_value,
                    description=self.tr(f"Attribute table field name for {field_value} [0s if not provided]"),
                    defaultValue=field_value,
                    parentLayerParameterName=self.IN_LAYER,
                    type=Qgis.ProcessingFieldParameterDataType.Numeric,
                    allowMultiple=False,
                    optional=True,
                    defaultToAllFields=False,
                )
            )
        # treatments
        self.addParameter(
            QgsProcessingParameterFile(
                name=self.IN_TREATS,
                description=self.tr("Treatments table (fid,treatment,value,value/m2,cost,cost/m2)"),
                behavior=QgsProcessingParameterFile.File,
                extension="csv",
                optional=True,
            )
        )
        # AREA double
        qppn = QgsProcessingParameterNumber(
            name=self.IN_AREA,
            description=self.tr("Total Area"),
            type=QgsProcessingParameterNumber.Double,
            defaultValue=2024.03,
            optional=False,
            minValue=0.01,
        )
        qppn.setMetadata({"widget_wrapper": {"decimals": 2}})
        self.addParameter(qppn)
        # BUDGET double
        qppn = QgsProcessingParameterNumber(
            name=self.IN_BUDGET,
            description=self.tr("Total Budget"),
            type=QgsProcessingParameterNumber.Double,
            defaultValue=1312.01,
            optional=False,
            minValue=0.01,
        )
        qppn.setMetadata({"widget_wrapper": {"decimals": 2}})
        self.addParameter(qppn)

        # output layer
        self.addParameter(QgsProcessingParameterFeatureSink(self.OUT_LAYER, self.tr("Polygon Treatment Output Layer")))
        # SOLVERS
        value_hints, self.solver_exception_msg = check_solver_availability(SOLVER)
        # solver string combobox (enums
        qpps = QgsProcessingParameterString(
            name="SOLVER",
            description="Solver: recommended options string [and executable STATUS]",
        )
        qpps.setMetadata(
            {
                "widget_wrapper": {
                    "value_hints": value_hints,
                    "setEditable": True,  # not working
                }
            }
        )
        qpps.setFlags(qpps.flags() | QgsProcessingParameterDefinition.FlagAdvanced)
        self.addParameter(qpps)
        # options_string
        qpps2 = QgsProcessingParameterString(
            name="CUSTOM_OPTIONS_STRING",
            description="Override options_string (type a single space ' ' to not send any options to the solver)",
            defaultValue="",
            optional=True,
        )
        qpps2.setFlags(qpps2.flags() | QgsProcessingParameterDefinition.FlagAdvanced)
        self.addParameter(qpps2)
        # executable file
        qppf = QgsProcessingParameterFile(
            name=self.IN_EXECUTABLE,
            description=self.tr("Set solver executable file [REQUIRED if STATUS]"),
            behavior=QgsProcessingParameterFile.File,
            extension="exe" if platform_system() == "Windows" else "",
            optional=True,
        )
        qppf.setFlags(qppf.flags() | QgsProcessingParameterDefinition.FlagAdvanced)
        self.addParameter(qppf)

        qppb = QgsProcessingParameterBoolean(
            name=self.GEOMETRY_CHECK_SKIP_INVALID,
            description=self.tr(
                "Set invalid geometry check to GeometrySkipInvalid (more options clicking the wrench on the input poly layer)"
            ),
            defaultValue=True,
            optional=True,
        )
        qppb.setFlags(qppb.flags() | QgsProcessingParameterDefinition.FlagAdvanced)
        self.addParameter(qppb)

    def processAlgorithm(self, parameters, context, feedback):
        retdic = {}
        # report solver unavailability
        feedback.pushWarning(f"Solver unavailability:\n{self.solver_exception_msg}\n")
        # invalid geometry skip
        if self.parameterAsBool(parameters, self.GEOMETRY_CHECK_SKIP_INVALID, context):
            context.setInvalidGeometryCheck(QgsFeatureRequest.GeometrySkipInvalid)
            feedback.pushWarning("setInvalidGeometryCheck set to GeometrySkipInvalid")
        # poly layer
        layer = self.parameterAsSource(parameters, self.IN_LAYER, context)
        feedback.pushDebugInfo(
            f"{layer.sourceName()=}, {layer.fields().names()=}, {layer.wkbType()=}, {layer.sourceCrs().authid()=}, {layer.featureCount()=}"
        )
        retdic["layer"] = layer
        # fields
        request_fields = []
        # required
        current_treatment_fieldname = self.parameterAsString(parameters, self.IN_TRT, context)
        request_fields += [current_treatment_fieldname]
        # optional
        if current_value_fieldname := self.parameterAsString(parameters, self.IN_VAL, context):
            request_fields += [current_value_fieldname]
        if current_valuem2_fieldname := self.parameterAsString(parameters, self.IN_VALm2, context):
            request_fields += [current_valuem2_fieldname]
        qfr = QgsFeatureRequest().setSubsetOfAttributes(request_fields, layer.fields())
        features = list(layer.getFeatures(qfr))
        feedback.pushWarning(
            f"Valid polygons: {len(features)}/{layer.featureCount()} {len(features)/layer.featureCount():.2%}\n"
        )
        # get else not provided
        if current_value_fieldname:
            current_value = [feat.attribute(current_value_fieldname) for feat in features]
        else:
            current_value = [0] * len(features)
        if current_valuem2_fieldname:
            current_valuem2 = [feat.attribute(current_valuem2_fieldname) for feat in features]
        else:
            current_valuem2 = [0] * len(features)
        attr_names = ["fid", "treatment", "value", "value/m2", "area"]
        dfa = pd.DataFrame.from_dict(
            dict(
                zip(
                    attr_names,
                    [
                        [feat.id() for feat in features],
                        [feat.attribute(current_treatment_fieldname) for feat in features],
                        current_value,
                        current_valuem2,
                        [feat.geometry().area() for feat in features],
                    ],
                )
            )
        )
        # feedback.pushDebugInfo(dfa)
        retdic["dfa"] = dfa
        # read tables
        dft = pd.read_csv(self.parameterAsFile(parameters, self.IN_TREATS, context))
        for col in ["fid", "treatment", "value", "value/m2", "cost", "cost/m2"]:
            if col not in dft.columns:
                raise QgsProcessingException(f"Column {col} not found in {dft.columns}")
        # feedback.pushDebugInfo(dft)
        retdic["dft"] = dft

        budget = self.parameterAsDouble(parameters, self.IN_BUDGET, context)
        area = self.parameterAsDouble(parameters, self.IN_AREA, context)

        treat_names = np.unique(dft["treatment"].to_list() + current_treatment).tolist()
        retdic["treat_names"] = treat_names

        treat_cube = np.zeros((len(dfa), len(treat_names), len(treat_names)), dtype=bool)
        for i, current in dfa.iterrows():
            # get targets
            targets = dft[dft["fid"] == current["fid"]]
            for _, target in targets.iterrows():
                treat_cube[i, treat_names.index(current["treatment"]), treat_names.index(target["treatment"])] = True
        # feedback.pushDebugInfo(f"{treat_cube=}")
        retdic["treat_cube"] = treat_cube

        feedback.pushDebugInfo(f"instance read: {retdic=}")

        return retdic

    def stop(self):
        """
        # fmt : off
        def at_most_one_treatment_rule(m, ii):
            return sum(m.X[i, j, k] for i, j, k in m.FeasibleSet if i == ii) <= 1

        m.at_most_one_treatment = pyo.Constraint(m.N, rule=at_most_one_treatment_rule)
        # fmt : on
        """

        feedback.pushDebugInfo(f"{response=}, {response.shape=}")
        # response[response == None] = -2
        assert N == len(response)

        undecided, skipped, not_selected, selected = np.histogram(response, bins=[-2, -1, 0, 1, 2])[0]
        feedback.pushInfo(
            "Solution histogram:\n"
            f"{selected=}\n"
            f"{not_selected=}\n"
            f"{skipped=} (invalid value or weight)\n"
            f"{undecided=}\n"
        )

        fields = QgsFields()
        fields.append(QgsField(name="fid", type=QVariant.Int))  # , len=10))
        fields.append(QgsField(name="knapsack", type=QVariant.Int))  # , len=10))

        (sink, dest_id) = self.parameterAsSink(
            parameters,
            self.OUT_LAYER,
            context,
            fields,
            layer.wkbType(),
            layer.sourceCrs(),
        )
        feedback.pushDebugInfo(f"{sink=}, {dest_id=}")

        total = 100.0 / N
        for current, feature in enumerate(features):
            # Stop the algorithm if cancel button has been clicked
            if feedback.isCanceled():
                break
            # Prepare feature
            new_feature = QgsFeature(fields)
            fid = int(feature.id())
            res = int(response[current])
            new_feature.setId(fid)
            new_feature.setAttributes([fid, res])
            new_feature.setGeometry(feature.geometry())
            # feedback.pushDebugInfo(f"{new_feature.id()=}, {current=}, {response[current]=}")
            # Add a feature in the sink
            sink.addFeature(new_feature, QgsFeatureSink.FastInsert)
            # Update the progress bar
            feedback.setProgress(int(current * total))

        # if showing
        if context.willLoadLayerOnCompletion(dest_id):
            layer_details = context.layerToLoadOnCompletionDetails(dest_id)
            layer_details.groupName = "DecisionOptimizationGroup"
            layer_details.name = "KnapsackPolygons"
            # layer_details.layerSortKey = 2
            processing.run(
                "native:setlayerstyle",
                {
                    "INPUT": dest_id,
                    "STYLE": str(Path(Path(__file__).parent, "assets", "knapsack_polygon.qml")),
                },
                context=context,
                feedback=feedback,
                is_child_algorithm=True,
            )

        write_log(feedback, name=self.name())
        return {
            self.OUT_LAYER: dest_id,
            "SOLVER_STATUS": status,
            "SOLVER_TERMINATION_CONDITION": termCondition,
        }

    def name(self):
        """processing.run('provider:name',{..."""
        return "bintrmt"

    def displayName(self):
        """
        Returns the translated algorithm name, which should be used for any
        user-visible display of the algorithm name.
        """
        return self.tr("AAA Polygon Treatment")

    # def group(self):
    #     return self.tr("Decision Optimization")

    # def groupId(self):
    #     return "do"

    def tr(self, string):
        return QCoreApplication.translate("Processing", string)

    def createInstance(self):
        return PolyTreatmentAlgorithm()

    def helpUrl(self):
        return "https://www.github.com/fdobad/qgis-processingplugin-template/issues"

    def shortDescription(self):
        return self.tr(
            """<b>Objetive:</b> Maximize the changed value of the treated polygons<br> 
               <b>Decisions:</b> Which treatment to apply to each polygon (or no change)<br>
               <b>Contraints:</b><br>
               (a) fixed+area costs less than budget<br>
               (b) treated area less than total area<br> 
               <b>Inputs:</b><br>
               (i) A polygon layer with <b>current</b> attributes: [fid],<b>treatment, value/m2, fixed_cost</b><br>
               (ii) A .csv table defining <b>target</b> treatments: <b>fid, treatment, value/m2, cost/m2</b> (use these column names)<br>
               - fid is the feature id of each polygon so it's given in the attribute table, but must be specified in the .csv table<br>
               - current & target treatment are just strings, but each polygon needs at least one feasible treatment (one row)<br>
               - current & target values/m2 weight towards the objective when no change or a target treatment is recommended respectively<br>
               (iii) <b>Budget</b> (same units than costs)<br>
               (iv) <b>Area</b> (same units than the geometry of the polygons)<br>
               <br>
               sample: """
            + (Path(__file__).parent / "treat_sample").as_uri()
        )

    def icon(self):
        return QIcon(":/plugins/fireanalyticstoolbox/assets/firebreakmap.svg")


def do_poly_treatment(fid, treat_names, treat_cube, dfa, dft, area, budget, feedback):
    # Mixed Integer Linear Programming
    m = pyo.ConcreteModel(name="polygon_treatment")

    # Sets
    m.N = pyo.Set(initialize=dfa.fid)
    m.T = pyo.Set(initialize=treat_names)
    m.FeasibleSet = pyo.Set(
        initialize=[
            (i, j, k)
            for i, j, k in product(m.N, m.T, m.T)
            if treat_cube[dfa[dfa.fid == i].index[0], treat_names.index(j), treat_names.index(k)]
        ]
    )

    # Params
    m.area = pyo.Param(m.N, within=pyo.Reals, initialize=dfa.set_index("fid")["area"].to_dict())
    m.current_value = pyo.Param(m.N, within=pyo.Reals, initialize=dfa.set_index("fid")["value"].to_dict())
    m.current_valuem2 = pyo.Param(m.N, within=pyo.Reals, initialize=dfa.set_index("fid")["value/m2"].to_dict())
    m.target_value = pyo.Param(
        m.N, m.T, within=pyo.Reals, initialize=dft.set_index(["fid", "treatment"])["value"].to_dict()
    )
    m.target_valuem2 = pyo.Param(
        m.N, m.T, within=pyo.Reals, initialize=dft.set_index(["fid", "treatment"])["value/m2"].to_dict()
    )
    m.cost = pyo.Param(m.N, m.T, within=pyo.Reals, initialize=dft.set_index(["fid", "treatment"])["cost"].to_dict())
    m.costm2 = pyo.Param(
        m.N, m.T, within=pyo.Reals, initialize=dft.set_index(["fid", "treatment"])["cost/m2"].to_dict()
    )

    # initialize=df_stands[treatments].stack().to_dict(),

    # Variables
    m.X = pyo.Var(
        m.FeasibleSet,
        within=pyo.Binary,
    )
    # Constraints
    m.at_most_one_treatment = pyo.Constraint(
        m.N, rule=lambda m, ii: sum(m.X[i, j, k] for i, j, k in m.FeasibleSet if i == ii) <= 1
    )

    m.area_capacity = pyo.Constraint(rule=lambda m: sum(m.X[i, j, k] * m.area[i] for i, j, k in m.FeasibleSet) <= area)

    m.budget_capacity = pyo.Constraint(
        rule=lambda m: sum(m.X[i, j, k] * (m.cost[i, k] + m.costm2[i, k] * m.area[i]) for i, j, k in m.FeasibleSet)
        <= budget
    )

    # Objective
    m.obj = pyo.Objective(
        expr=sum(
            m.X[i, j, k] * (m.target_value[i, k] + m.target_valuem2[i, k] * m.area[i])
            + (1 - m.X[i, j, k]) * (m.current_value[i] + m.current_valuem2[i] * m.area[i])
            for i, j, k in m.FeasibleSet
        ),
        sense=pyo.maximize,
    )
    print("PPRINT")
    print(m.pprint())

    # Solve
    solver = "cbc"
    executable = None
    if executable:
        opt = SolverFactory(solver, executable=executable)
    else:
        opt = SolverFactory(solver)

    options_string = None
    if options_string:
        results = opt.solve(m, tee=True, options_string=options_string)
    else:
        results = opt.solve(m, tee=True)

    print("DISPLAY")
    print(m.display())
    # for i, j, k in m.AllSets:
    #     print(i, j, k, pyo.value(m.X[i, j, k], exception=False))
