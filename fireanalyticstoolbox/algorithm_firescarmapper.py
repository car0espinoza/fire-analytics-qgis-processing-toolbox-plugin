"""
/***************************************************************************
 FireToolbox
                                 A QGIS plugin
 A collection of fire insights related algorithms
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2023-08-30
        copyright            : (C) 2024 by Diego Teran - Fire2a.com
        email                : FIX-ME
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

"""
TODO:
- initAlgorithm con Fernando
- como incorporar las credenciales que se pongan
- ver el tema del feedback que se está dando cuando se están ejecutando las cosas (está en "No responde" mientras se está ejecutando)
- ver el color de las bandas de las imagenes 
- arreglar el ordenador para que suba cualquier archivo que esté y que termine con el mismo path
"""


from fire2a.raster import get_rlayer_data
import os
from qgis.core import (QgsProcessingAlgorithm, QgsProject, QgsRasterLayer, QgsProcessingException, QgsLayerTreeLayer, QgsGradientColorRamp, QgsSingleBandPseudoColorRenderer)
from qgis.PyQt.QtCore import QCoreApplication
from qgis.PyQt.QtGui import QColor
import boto3
from .firescarmapping.model_u_net import model, device  # Importar el modelo y dispositivo necesarios
from .firescarmapping.as_dataset import create_datasetAS
from .firescarmapping.bucketdisplay import S3SelectionDialog, AWSCredentialsDialog, get_aws_credentials
import numpy as np
from torch.utils.data import DataLoader
from osgeo import gdal, gdal_array
import torch


class FireScarMapper(QgsProcessingAlgorithm):
    S3_BUCKET = "fire2a-firescars"
    AWS_ACCESS_KEY_ID_PARAM = "AWSAccessKeyId"
    AWS_SECRET_ACCESS_KEY_PARAM = "AWSSecretAccessKey"
    
    def initAlgorithm(self, config):
        pass

    def download_file_from_s3(self, bucket_name, file_name, local_path, access_key_id, secret_access_key):
        s3 = boto3.client(
            's3',
            aws_access_key_id=access_key_id,
            aws_secret_access_key=secret_access_key,
            region_name="us-east-1"
        )
        try:
            s3.download_file(bucket_name, file_name, local_path)
        except Exception as e:
            raise QgsProcessingException(f"Failed to download {file_name} from S3: {str(e)}")
    
    def firescarselector(self, access_key_id, secret_access_key, feedback):
        dialog_locality = S3SelectionDialog(self.S3_BUCKET, access_key_id, secret_access_key, prefix="Images/")
        if dialog_locality.exec_():
            selected_locality = dialog_locality.get_selected_item()  
            feedback.pushDebugInfo(f"selected_locality: {selected_locality}")

            dialog_year = S3SelectionDialog(self.S3_BUCKET, access_key_id, secret_access_key, prefix=selected_locality)
            if dialog_year.exec_():
                selected_year = dialog_year.get_selected_item()  
                feedback.pushDebugInfo(f"selected_year: {selected_year}")

                dialog_month = S3SelectionDialog(self.S3_BUCKET, access_key_id, secret_access_key, prefix=selected_year)
                if dialog_month.exec_():
                    selected_month = dialog_month.get_selected_item()  
                    feedback.pushDebugInfo(f"selected_month: {selected_month}")

                    dialog_day = S3SelectionDialog(self.S3_BUCKET, access_key_id, secret_access_key, prefix=selected_month)
                    if dialog_day.exec_():
                        selected_day = dialog_day.get_selected_item()  
                        feedback.pushDebugInfo(f"selected_day: {selected_day}")

                        dialog_pairs = S3SelectionDialog(self.S3_BUCKET, access_key_id, secret_access_key, prefix=selected_day)
                        if dialog_pairs.exec_():
                            selected_pair_folder = dialog_pairs.get_selected_item()  
                            feedback.pushDebugInfo(f"selected_pair_folder: {selected_pair_folder}")
                            return selected_pair_folder, selected_locality
                            
                        
                        raise QgsProcessingException("Invalid wildfire incident folder or not selected")    
                    raise QgsProcessingException("Invalid day or not selected")
                raise QgsProcessingException("Invalid month or not selected")                
            raise QgsProcessingException("Invalid year or not selected")
        raise QgsProcessingException("Invalid locality or not selected")
    
    def processAlgorithm(self, parameters, context, feedback):
        aws_access_key_id, aws_secret_access_key = get_aws_credentials()
        selected_pair_folder, selected_locality = self.firescarselector(aws_access_key_id, aws_secret_access_key, feedback)
                                                           
        # List files inside the folder
        s3 = boto3.client(
            's3',
            aws_access_key_id=aws_access_key_id,
            aws_secret_access_key=aws_secret_access_key,
            region_name="us-east-1"
        )
        paginator = s3.get_paginator('list_objects_v2')
        try:
            files = []
            for result in paginator.paginate(Bucket=self.S3_BUCKET, Prefix=selected_pair_folder):
                if 'Contents' in result:
                    files.extend([obj['Key'] for obj in result['Contents'] if obj['Key'].endswith('.tif')])
            
            # Exctract components of the path
            path_components = selected_pair_folder.split('/')[1:]  # Ignore first component "Images"

            # Create complete path
            local_base_path = os.path.join(os.path.dirname(__file__), "results", *path_components[:-1])
            os.makedirs(local_base_path, exist_ok=True)
            exists_RdNBR = False
            exists_Severity = False
            for file in files:
                if 'ImgPreF' in file: 
                    imgpre_filename = file.split('/')[-1]
                    local_path_before = os.path.join(local_base_path, imgpre_filename)
                    feedback.pushDebugInfo(f"{local_path_before=}")

                    if not os.path.exists(local_path_before):
                        feedback.pushDebugInfo(f"Downloading file: {file} to {local_path_before}")
                        self.download_file_from_s3(self.S3_BUCKET, file, local_path_before, aws_access_key_id, aws_secret_access_key)
                        feedback.pushDebugInfo(f"before layer  file.split('/')[2][:-23]= {file.split('/')[2][:-23]}")
                    before_layer = QgsRasterLayer(local_path_before, f"{file.split('/')[2][:-23]}")

                elif 'ImgPosF' in file:
                    imgpost_filename = file.split('/')[-1]
                    local_path_burnt = os.path.join(local_base_path, imgpost_filename)
                    feedback.pushDebugInfo(f"{local_path_burnt=}")

                    if not os.path.exists(local_path_burnt):
                        feedback.pushDebugInfo(f"Downloading file: {file} to {local_path_burnt}")
                        self.download_file_from_s3(self.S3_BUCKET, file, local_path_burnt, aws_access_key_id, aws_secret_access_key)
                    burnt_layer = QgsRasterLayer(local_path_burnt, f"{file.split('/')[2][:-23]}")
                
                elif 'RdNBR' in file:
                    exists_RdNBR = True
                    rdnbr_filename = file.split('/')[-1]
                    local_path_rdnbr = os.path.join(local_base_path, rdnbr_filename)
                    feedback.pushDebugInfo(f"{local_path_rdnbr=}")

                    if not os.path.exists(local_path_rdnbr):
                        feedback.pushDebugInfo(f"Downloading file: {file} to {local_path_rdnbr}")
                        self.download_file_from_s3(self.S3_BUCKET, file, local_path_rdnbr, aws_access_key_id, aws_secret_access_key)
                
            firescar_filename = imgpre_filename.replace('ImgPreF', 'FireScar')
            output_path = os.path.join(local_base_path, firescar_filename)
            firescar_s3_path = selected_pair_folder + firescar_filename
            feedback.pushDebugInfo(f"{firescar_s3_path=}")  
            feedback.pushDebugInfo(f"output path: {output_path}")  

            local_firescar = True
            firescar_in_s3 = True
            if not os.path.exists(output_path): #if it's not locally
                local_firescar = False
                feedback.pushDebugInfo(f"the firescar is not locally")
                if self.file_exists_in_s3(self.S3_BUCKET, firescar_s3_path, aws_access_key_id, aws_secret_access_key): #if it is in s3
                    feedback.pushDebugInfo(f"Downloading file: {firescar_s3_path} to {output_path}")
                    self.download_file_from_s3(self.S3_BUCKET, firescar_s3_path, output_path, aws_access_key_id, aws_secret_access_key)
                else:
                    feedback.pushDebugInfo(f"the firescar is not in s3")
                    firescar_in_s3 = False                                
                            
        except Exception as e:
            raise QgsProcessingException(f"Failed to list or download files from S3: {str(e)}")
        
    
        if not local_firescar and not firescar_in_s3:
            # Download model if it's not locally
            model_path = os.path.join(os.path.dirname(__file__), 'firescarmapping', 'ep25_lr1e-04_bs16_021__as_std_adam_f01_13_07_x3.model')
            if not os.path.exists(model_path):
                self.download_file_from_s3(self.S3_BUCKET, "Model/ep25_lr1e-04_bs16_021__as_std_adam_f01_13_07_x3.model", model_path, aws_access_key_id, aws_secret_access_key)
            else:
                feedback.pushDebugInfo(f"Model already exists at {model_path}")

            # Prepare data fot  the evaluation of the model
            rasters = [
                {"type": "before", "id": 0, "qid": before_layer.id(), "name": before_layer.name(), "data": get_rlayer_data(before_layer), "layer": before_layer},
                {"type": "burnt", "id": 1, "qid": burnt_layer.id(), "name": burnt_layer.name(), "data": get_rlayer_data(burnt_layer), "layer": burnt_layer}
            ]

            before_files_data = [rasters[0]['data']]
            after_files_data = [rasters[1]['data']]

            # Load model and evaluate the generated firescar
            device = torch.device('cuda:0' if torch.cuda.is_available() else 'cpu')
            model.load_state_dict(torch.load(model_path, map_location=torch.device('cpu')))
            np.random.seed(3)
            torch.manual_seed(3)
            data_eval = create_datasetAS(before_files_data, after_files_data, mult=1)
            batch_size = 1 
            all_dl = DataLoader(data_eval, batch_size=batch_size)

            model.eval()
            for i, batch in enumerate(all_dl):
                feedback.pushDebugInfo(f"Processing batch {i}")
                x = batch['img'].float().to(device)
                feedback.pushDebugInfo(f"Input shape: {x.shape}")
                output = model(x).cpu()
                feedback.pushDebugInfo(f"Output shape: {output.shape}")

                # Obtain the map of binary prediction
                pred = np.zeros(output.shape)
                pred[output >= 0] = 1

                generated_matrix = pred[0][0]

        if output_path:
            if not local_firescar and not firescar_in_s3:
                feedback.pushDebugInfo(f"Writing raster to: {output_path}")
                # Call function to write georeferenced raster
                self.writeRaster(generated_matrix, output_path, before_layer, feedback)
                feedback.pushDebugInfo(f"Adding raster layer: {output_path}")

            #verify if the firescar is in s3
            if not self.file_exists_in_s3(self.S3_BUCKET, firescar_s3_path, aws_access_key_id, aws_secret_access_key):
                feedback.pushDebugInfo(f"Uploading file: {firescar_filename} to {selected_pair_folder}")
                s3.upload_file(output_path, self.S3_BUCKET, firescar_s3_path)

            # verify if the group already exists, if not, creates it
            group_name = f"{selected_locality.split('/')[1]} - {selected_pair_folder.split('/')[5]}"
            root = QgsProject.instance().layerTreeRoot()
            group = root.findGroup(group_name)
            if not group:
                group = root.addGroup(group_name)
            self.addRasterLayer(local_path_before, f"ImgPreF-{selected_pair_folder.split('/')[1]}-{selected_pair_folder.split('/')[5]}", group, context)
            self.addRasterLayer(local_path_burnt, f"ImgPosF-{selected_pair_folder.split('/')[1]}-{selected_pair_folder.split('/')[5]}", group, context)
            self.addRasterLayer(output_path, f"FireScar-{selected_pair_folder.split('/')[1]}-{selected_pair_folder.split('/')[5]}", group, context)
            if exists_RdNBR:
                self.addRasterLayer(local_path_rdnbr, f"RdNBR-{selected_pair_folder.split('/')[1]}-{selected_pair_folder.split('/')[5]}", group, context)
            if exists_Severity:
                self.addRasterLayer(local_path_severity, f"Severity-{selected_pair_folder.split('/')[1]}-{selected_pair_folder.split('/')[5]}", group, context)
            self.add_openstreetmap_layer_if_needed(feedback)  
        return {}

        
    def file_exists_in_s3(self, bucket, key, access_key_id, secret_access_key):
        s3 = boto3.client(
            's3',
            aws_access_key_id=access_key_id,
            aws_secret_access_key=secret_access_key,
            region_name="us-east-1"
        )
        try:
            s3.head_object(Bucket=bucket, Key=key)
            return True
        except:
            return False
        
    def add_openstreetmap_layer_if_needed(self, feedback):
        # Verificar si ya hay una capa OpenStreetMap
        project = QgsProject.instance()
        layers = project.mapLayers().values()
        for layer in layers:
            if layer.name() == "OpenStreetMap":
                feedback.pushDebugInfo(f"OpenStreetMap layer already exists.")
                return

        # URL del tile server de OpenStreetMap
        urlWithParams = 'type=xyz&url=http://a.tile.openstreetmap.org/{z}/{x}/{y}.png'
        
        # Crear la capa OpenStreetMap
        layer = QgsRasterLayer(urlWithParams, 'OpenStreetMap', 'wms')
        
        # Verificar si la capa fue creada correctamente
        if not layer.isValid():
            feedback.pushDebugInfo(f"Failed to create OpenStreetMap layer")
            return
        
        # Agregar la capa al proyecto
        project.addMapLayer(layer)
        feedback.pushDebugInfo(f"OpenStreetMap layer added.")
        
    def addRasterLayer(self, file_path, layer_name, group, context):
        layer = QgsRasterLayer(file_path, layer_name, "gdal")
        if not layer.isValid():
            raise QgsProcessingException(f"Failed to load raster layer from {file_path}")
        
        provider = layer.dataProvider()
        if provider:
            for band in range(1, layer.bandCount() + 1):
                provider.setNoDataValue(band, 0)
            layer.triggerRepaint()

        QgsProject.instance().addMapLayer(layer, False)
        group.insertChildNode(0, QgsLayerTreeLayer(layer))
        if "Firescar" in layer_name:
            renderer = layer.renderer()
            if isinstance(renderer, QgsSingleBandPseudoColorRenderer):
                color_ramp = QgsGradientColorRamp(QColor(255, 255, 255), QColor(0, 0, 0))
                renderer.updateColorRamp(color_ramp)
                layer.triggerRepaint()

    def writeRaster(self, matrix, file_path, before_layer, feedback):

        # Get the dimensions of the raster before the fire
        width = before_layer.width()
        height = before_layer.height()

        # Create the output raster file
        driver = gdal.GetDriverByName('GTiff')
        raster = driver.Create(file_path, width, height, 1, gdal.GDT_Byte)

        if raster is None:
            raise QgsProcessingException("Failed to create raster file.")

        # Set the geotransformation and projection
        extent = before_layer.extent()
        pixel_width = extent.width() / width
        pixel_height = extent.height() / height
        raster.SetGeoTransform((extent.xMinimum(), pixel_width, 0, extent.yMaximum(), 0, -pixel_height))
        raster.SetProjection(before_layer.crs().toWkt())

        # Get the raster band
        band = raster.GetRasterBand(1)

        # Calculate the offset and size of the burn scar region to fit the raster
        start_row = 0
        start_col = 0
        matrix_height, matrix_width = matrix.shape

        if matrix_height > height:
            start_row = (matrix_height - height) // 2
            matrix_height = height
        if matrix_width > width:
            start_col = (matrix_width - width) // 2
            matrix_width = width

        # Crop the matrix to match the raster dimensions
        resized_matrix = matrix[start_row:start_row + matrix_height, start_col:start_col + matrix_width]

        # Write the matrix to the raster band
        try:
            gdal_array.BandWriteArray(band, resized_matrix, 0, 0)
        except ValueError as e:
            raise QgsProcessingException(f"Failed to write array to raster: {str(e)}")

        # Set the NoData value
        band.SetNoDataValue(0)
        
        # Ensure that the minimum and maximum values are updated
        band.ComputeStatistics(False)
        band.SetStatistics(0, 1, 0.5, 0.5)

        # Flush cache and close the raster
        band.FlushCache()
        raster.FlushCache()
        raster = None

        feedback.pushInfo(f"Raster written to {file_path}")

    def name(self):
        return "firescarmapper"
    
    def displayName(self):
        return self.tr("Fire Scar Mapper")

    def tr(self, string):
        return QCoreApplication.translate("Processing", string)

    def createInstance(self):
        return FireScarMapper()
