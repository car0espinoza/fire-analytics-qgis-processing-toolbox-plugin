"""
/***************************************************************************
 FireToolbox
                                 A QGIS plugin
 A collection of fire insights related algorithms
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2023-08-30
        copyright            : (C) 2024 by Diego Teran - Fire2a.com
        email                : FIX-ME
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import boto3
import os
from fire2a.raster import get_rlayer_data
from qgis.core import (QgsProcessing, QgsProcessingAlgorithm, QgsProcessingParameterRasterDestination,
                       QgsProject, QgsRasterLayer, QgsProcessingException)
from qgis.PyQt.QtCore import QCoreApplication
import torch
from .firescarmapping.model_u_net import model, device
from .firescarmapping.as_dataset import create_datasetAS
import numpy as np
from torch.utils.data import DataLoader
from osgeo import gdal, osr

class FireScarMapper(QgsProcessingAlgorithm):
    OUT_SCARS = "OutputScars"
    S3_BUCKET = "fire2a-firescars"
    AWS_ACCESS_KEY_ID = "<AWS_ACCESS_KEY_ID>"
    AWS_SECRET_ACCESS_KEY = "<AWS_SECRET_ACCESS_KEY>"

    def download_file_from_s3(self, bucket_name, file_name, local_path, access_key_id, secret_access_key, region_name='us-east-1'):
        s3 = boto3.client(
            's3',
            aws_access_key_id=access_key_id,
            aws_secret_access_key=secret_access_key,
            region_name=region_name
        )
        s3.download_file(bucket_name, file_name, local_path)

    def initAlgorithm(self, config):
        self.addParameter(
            QgsProcessingParameterRasterDestination(
                name=self.OUT_SCARS,
                description=self.tr("Output mapped scars in a single raster"),
            )
        )

    def processAlgorithm(self, parameters, context, feedback):
        # Path to download the images
        local_path_before = os.path.join(os.path.dirname(__file__), 'temp_before.tif')
        local_path_burnt = os.path.join(os.path.dirname(__file__), 'temp_burnt.tif')

        # Define S3 paths
        s3_path_before = 'Biobio/ID74101/ImgPreF_CL-BI_ID74101_u350_19980330_clip.tif'
        s3_path_burnt = 'Biobio/ID74101/ImgPosF_CL-BI_ID74101_u350_19980330_clip.tif'

        # Log the paths
        feedback.pushDebugInfo(f"Downloading from S3 bucket: {self.S3_BUCKET}")
        feedback.pushDebugInfo(f"Before image path: {s3_path_before}")
        feedback.pushDebugInfo(f"Burnt image path: {s3_path_burnt}")

        # Download images from S3
        try:
            self.download_file_from_s3(self.S3_BUCKET, s3_path_before, local_path_before, self.AWS_ACCESS_KEY_ID, self.AWS_SECRET_ACCESS_KEY)
            self.download_file_from_s3(self.S3_BUCKET, s3_path_burnt, local_path_burnt, self.AWS_ACCESS_KEY_ID, self.AWS_SECRET_ACCESS_KEY)
        except Exception as e:
            raise QgsProcessingException(f"Failed to download files from S3: {str(e)}")

        # Load downloaded images as raster layers
        before_layer = QgsRasterLayer(local_path_before, "Before Raster")
        burnt_layer = QgsRasterLayer(local_path_burnt, "Burnt Raster")

        if not before_layer.isValid() or not burnt_layer.isValid():
            raise QgsProcessingException("Failed to load raster layers from the downloaded images")

        feedback.pushDebugInfo(f"Downloaded rasters:\n names: {[before_layer.name(), burnt_layer.name()]}\ntypes: {[before_layer.rasterType(), burnt_layer.rasterType()]}")

        model_path = os.path.join(os.path.dirname(__file__), 'firescarmapping', 'ep25_lr1e-04_bs16_021__as_std_adam_f01_13_07_x3.model')
        output_path = self.parameterAsOutputLayer(parameters, self.OUT_SCARS, context)

        rasters = [
            {"type": "before", "id": 0, "qid": before_layer.id(), "name": before_layer.name()[8:], "data": get_rlayer_data(before_layer), "layer": before_layer},
            {"type": "burnt", "id": 1, "qid": burnt_layer.id(), "name": burnt_layer.name()[8:], "data": get_rlayer_data(burnt_layer), "layer": burnt_layer}
        ]

        before_files = [rasters[0]]
        after_files = [rasters[1]]
        before_files_data = [before_files[0]['data']]
        after_files_data = [after_files[0]['data']]

        device = torch.device('cuda:0' if torch.cuda.is_available() else 'cpu')
        model.load_state_dict(torch.load(model_path, map_location=torch.device('cpu')))

        np.random.seed(3)
        torch.manual_seed(3)

        data_eval = create_datasetAS(before_files_data, after_files_data, mult=1)

        batch_size = 1  # 1 to create diagnostic images, any value otherwise
        all_dl = DataLoader(data_eval, batch_size=batch_size)  #, shuffle=True)

        model.eval()

        for i, batch in enumerate(all_dl):
            x = batch['img'].float().to(device)
            output = model(x).cpu()

            # obtain binary prediction map
            pred = np.zeros(output.shape)
            pred[output >= 0] = 1

            generated_matrix = pred[0][0]

            if output_path:
                # Adjust the name of the output path to be unique for each firescar
                output_path_with_index = output_path[:-4] + f"_{i+1}.tif"
                self.writeRaster(generated_matrix, output_path_with_index, context)
                self.addRasterLayer(output_path_with_index, before_files[i]['name'], context)

        return {}

    def writeRaster(self, matrix, file_path, context):
        height, width = matrix.shape

        driver = gdal.GetDriverByName('GTiff')
        raster = driver.Create(file_path, width, height, 1, gdal.GDT_Int16)

        originX = 0
        originY = 0
        pixelWidth = 1
        pixelHeight = 1

        raster.SetGeoTransform((originX, pixelWidth, 0, originY, 0, -pixelHeight))

        spatialReference = osr.SpatialReference()
        spatialReference.ImportFromEPSG(4326)
        raster.SetProjection(spatialReference.ExportToWkt())

        band = raster.GetRasterBand(1)
        band.WriteArray(matrix)

        band.FlushCache()
        raster.FlushCache()
        raster = None

    def addRasterLayer(self, file_path, layer_name, context):
        layer = QgsRasterLayer(file_path, layer_name, "gdal")
        if not layer.isValid():
            raise QgsProcessingException(f"Failed to load raster layer from {file_path}")

        QgsProject.instance().addMapLayer(layer)

    def name(self):
        return "firescarmapper"
    
    def displayName(self):
        return self.tr("Fire Scar Mapper")

    def tr(self, string):
        return QCoreApplication.translate("Processing", string)

    def createInstance(self):
        return FireScarMapper()




