#!python3
"""
/***************************************************************************
 FireToolbox
                                 A QGIS plugin
 A collection of fire insights related algorithms
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2023-08-30
        copyright            : (C) 2024 by Diego Teran - Fire2a.com
        email                : FIX-ME
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

from pathlib import Path
from tempfile import NamedTemporaryFile

import processing
from fire2a.raster import get_rlayer_data, get_rlayer_info
from qgis.core import (QgsProcessing, QgsProcessingAlgorithm, QgsProcessingParameterMultipleLayers,
                       QgsProcessingParameterRasterDestination, QgsProcessingParameterFile, QgsProject)
from qgis.PyQt.QtCore import QCoreApplication
from qgis.PyQt.QtGui import QIcon
from .algorithm_utils import write_log

import torch
from .model_u_net import model
import numpy as np
import pandas as pd
from torch.utils.data import DataLoader
from sklearn.metrics import jaccard_score, accuracy_score
import torch.nn as nn


class FireScarMapper(QgsProcessingAlgorithm):
    IN_BEFORE = "BeforeRasters"
    IN_AFTER = "AfterRasters"
    OUT_SCARS = "OutputScars"
    IN_MODEL = "Trained Model"

    def initAlgorithm(self, config):
        self.addParameter(
            QgsProcessingParameterMultipleLayers(
                name=self.IN_BEFORE,
                description=self.tr("Input rasters of non burned landscape"),
                layerType=QgsProcessing.TypeRaster,
                defaultValue=[],
                optional=False,
            )
        )
        self.addParameter(
            QgsProcessingParameterMultipleLayers(
                name=self.IN_AFTER,
                description=self.tr("Input rasters of burnt landscape"),
                layerType=QgsProcessing.TypeRaster,
                defaultValue=[],
                optional=False,
            )
        )
        self.addParameter(
            QgsProcessingParameterFile(
                name=self.IN_MODEL,
                description=self.tr("Trained model file"),
                extension="model",
                optional=False,
            )
        )
        self.addParameter(
            QgsProcessingParameterRasterDestination(
                name=self.OUT_SCARS,
                description=self.tr("Output mapped scars in a single raster"),
            )
        )

    def processAlgorithm(self, parameters, context, feedback):
        before = self.parameterAsLayerList(parameters, self.IN_BEFORE, context)
        after = self.parameterAsLayerList(parameters, self.IN_AFTER, context)
        model_path = self.parameterAsFile(parameters, self.IN_MODEL, context)

        if len(before) != len(after):
            raise QgsProcessingException("The number of before and after rasters must be the same")

        # Load the model
        device = torch.device('cuda:0' if torch.cuda.is_available() else 'cpu')
        model.load_state_dict(torch.load(model_path, map_location=torch.device('cpu')))
        model.eval()

        scars_data = []

        for b_layer, a_layer in zip(before, after):
            # Get data from before and after rasters
            before_data = get_rlayer_data(b_layer)
            after_data = get_rlayer_data(a_layer)

            # Assuming both before_data and after_data are numpy arrays
            # Combine them into a single input tensor for the model
            input_data = np.concatenate((before_data, after_data), axis=0)
            input_tensor = torch.from_numpy(input_data).float().unsqueeze(0).to(device)

            # Pass input through the model to get the scar prediction
            with torch.no_grad():
                output_tensor = model(input_tensor)

            # Assuming output_tensor is the predicted scar mask as a tensor
            # Convert it back to numpy array
            scar_data = output_tensor.cpu().numpy()

            # Append the scar data to the list
            scars_data.append(scar_data)
        
        # Combine all scar predictions into a single numpy array
        combined_scars_data = np.concatenate(scars_data, axis=0)
       # Aplicar umbral a la matriz generada por el modelo
        threshold = 1e-4  # Puedes ajustar este valor según sea necesario
        binary_scar_data = (combined_scars_data > threshold).astype(np.uint8)
        # Ajustar la configuración de impresión de NumPy para imprimir la matriz completa
        np.set_printoptions(threshold=np.inf, linewidth=np.inf)
        # Convertir la matriz binaria a una cadena de texto
        binary_scar_data_str = np.array2string(binary_scar_data, separator=', ')

        # Mostrar la matriz binaria en la consola de depuración
        feedback.pushDebugInfo(binary_scar_data_str)
        
        """
        combined_scars_data = np.concatenate(scars_data, axis=0)
        # Convertir la matriz numpy a una cadena de texto
        scar_data_str = np.array2string(combined_scars_data, separator=', ')

        # Mostrar la matriz en la consola de depuración
        feedback.pushDebugInfo(scar_data_str)
        """
        return {}

    def name(self):
        return "firescarmapper"
    
    def displayName(self):
        return self.tr("Fire Scar Mapper")

    def tr(self, string):
        return QCoreApplication.translate("Processing", string)

    def createInstance(self):
        return FireScarMapper()
